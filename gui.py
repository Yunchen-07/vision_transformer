import sys
import os
import shutil
import json
import warnings
from datetime import datetime

import cv2
from PIL import Image

import torch
import torch.nn as nn
from torchvision import transforms
from model_vision_transformer import vit_base_patch16_224_in21k

# 导入CNN和ResNet18模型定义
from cnn_train import EmotionCNN
from resnet18_train import ResNet18

from PyQt5 import QtCore
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *

from ui import Ui_MainWindow

# 禁用警告信息
warnings.filterwarnings('ignore')
os.environ['KMP_DUPLICATE_LIB_OK'] = 'True'


class ResultDialog(QDialog):
    """模型性能对比结果展示对话框"""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_time = "2025-05-19 10:23:43"  # UTC time
        self.current_user = "Yunchen-07"

        self.setWindowTitle(f"Model Performance Comparison - {self.current_time}")
        self.setFixedSize(800, 600)

        # 创建标签页
        tab_widget = QTabWidget()

        # F1-score标签页
        f1_tab = QLabel()
        f1_pixmap = QPixmap(
            r"C:\Users\Masiwei\PycharmProjects\pythonProject\总可视化\visualization_output1\comparison_f1-score.png")
        f1_pixmap = f1_pixmap.scaled(780, 550, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation)
        f1_tab.setPixmap(f1_pixmap)
        tab_widget.addTab(f1_tab, "F1-score")

        # Precision标签页
        precision_tab = QLabel()
        precision_pixmap = QPixmap(
            r"C:\Users\Masiwei\PycharmProjects\pythonProject\总可视化\visualization_output1\comparison_precision.png")
        precision_pixmap = precision_pixmap.scaled(780, 550, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation)
        precision_tab.setPixmap(precision_pixmap)
        tab_widget.addTab(precision_tab, "Precision")

        # Recall标签页
        recall_tab = QLabel()
        recall_pixmap = QPixmap(
            r"C:\Users\Masiwei\PycharmProjects\pythonProject\总可视化\visualization_output1\comparison_recall.png")
        recall_pixmap = recall_pixmap.scaled(780, 550, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation)
        recall_tab.setPixmap(recall_pixmap)
        tab_widget.addTab(recall_tab, "Recall")

        # 添加信息标签
        info_label = QLabel(f"Generated by: {self.current_user} at {self.current_time}")
        info_label.setAlignment(QtCore.Qt.AlignRight)

        # 设置布局
        layout = QVBoxLayout()
        layout.addWidget(tab_widget)
        layout.addWidget(info_label)
        self.setLayout(layout)


class MyWindow(QMainWindow, Ui_MainWindow):
    def __init__(self):
        super().__init__()
        # 设置时间和用户信息
        self.current_time = "2025-05-19 10:23:43"  # UTC time
        self.current_user = "Yunchen-07"

        # 设置设备
        self.device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

        # 获取类别字典
        self.class_indict = self.get_class_dict()
        self.image_path = None

        # 初始化模型字典为None
        self.models = {
            "Vision Transformer": None,
            "CNN": None,
            "ResNet18": None
        }

        # 设置当前模型为None
        self.current_model = None

        # 设置UI
        self.setupUi(self)
        self.setWindowFlag(QtCore.Qt.FramelessWindowHint)
        self.setAttribute(QtCore.Qt.WA_TranslucentBackground)

        # 连接信号和槽
        self.pushButton.clicked.connect(self.change_img)
        self.pushButton_2.clicked.connect(self.predict_img)
        self.pushButton_4.clicked.connect(self.show_model_comparison)
        self.modelComboBox.currentTextChanged.connect(self.change_model)

        # 初始加载ViT模型
        self.load_initial_model()

    def load_initial_model(self):
        """初始加载ViT模型"""
        try:
            print(f"\nInitializing ViT model at {self.current_time}")
            print(f"User: {self.current_user}")
            print(f"Device: {self.device}")

            self.models["Vision Transformer"] = self.load_vit_model()
            self.current_model = self.models["Vision Transformer"]
            if self.current_model is not None:
                self.current_model.eval()
                print("✓ ViT模型初始化成功")

        except Exception as e:
            print(f"❌ 初始模型加载失败: {str(e)}")
            QMessageBox.critical(self, "错误", f"初始模型加载失败: {str(e)}")

    def get_class_dict(self):
        """获取类别映射字典"""
        json_path = 'static/json/class_indices.json'
        assert os.path.exists(json_path), f"文件不存在: '{json_path}'"
        with open(json_path, "r", encoding="utf-8") as f:
            class_indict = json.load(f)
        return class_indict

    def load_vit_model(self):
        """加载Vision Transformer模型"""
        try:
            model = vit_base_patch16_224_in21k(num_classes=len(self.class_indict),
                                               has_logits=False).to(self.device)
            model.load_state_dict(torch.load("models/vision_transformer.pth",
                                             map_location=self.device))
            model.eval()
            print("✓ ViT模型加载成功")
            return model
        except Exception as e:
            print(f"❌ ViT模型加载失败: {str(e)}")
            return None

    def load_cnn_model(self):
        """加载CNN模型"""
        try:
            model = EmotionCNN(num_classes=len(self.class_indict)).to(self.device)
            checkpoint = torch.load("CNN_result/best_model.pth",
                                    map_location=self.device)
            model.load_state_dict(checkpoint['model_state_dict'])
            model.eval()
            print("✓ CNN模型加载成功")
            return model
        except Exception as e:
            print(f"❌ CNN模型加载失败: {str(e)}")
            return None

    def load_resnet18_model(self):
        """加载ResNet18模型"""
        try:
            model = ResNet18(num_classes=len(self.class_indict)).to(self.device)
            checkpoint = torch.load("ResNet18_results/best_model.pth",
                                    map_location=self.device)
            model.load_state_dict(checkpoint['model_state_dict'])
            model.eval()
            print("✓ ResNet18模型加载成功")
            return model
        except Exception as e:
            print(f"❌ ResNet18模型加载失败: {str(e)}")
            return None

    def show_model_comparison(self):
        """显示模型性能对比结果"""
        try:
            dialog = ResultDialog(self)
            dialog.exec_()
        except Exception as e:
            print(f"❌ 显示模型性能对比结果出错: {str(e)}")
            QMessageBox.critical(self, "错误", f"显示结果失败: {str(e)}")

    def change_model(self, model_name):
        """切换预测模型"""
        try:
            print(f"\nSwitching model at {self.current_time}")
            print(f"User: {self.current_user}")
            print(f"Switching to: {model_name}")

            # 如果模型未加载，则加载模型
            if self.models[model_name] is None:
                if model_name == "Vision Transformer":
                    self.models[model_name] = self.load_vit_model()
                elif model_name == "CNN":
                    self.models[model_name] = self.load_cnn_model()
                elif model_name == "ResNet18":
                    self.models[model_name] = self.load_resnet18_model()

            # 检查模型是否成功加载
            if self.models[model_name] is not None:
                # 将模型移动到正确的设备上
                self.models[model_name] = self.models[model_name].to(self.device)
                self.current_model = self.models[model_name]
                self.current_model.eval()
                print(f"✓ 成功切换到模型: {model_name}")
            else:
                print(f"❌ 模型 {model_name} 加载失败")
                QMessageBox.warning(self, "警告", f"模型 {model_name} 加载失败")

            # 清空之前的预测结果
            self.label_3.setText("")
            self.label_4.setText("")

        except Exception as e:
            print(f"❌ 模型切换错误: {str(e)}")
            QMessageBox.critical(self, "错误", f"模型切换失败: {str(e)}")
            # 恢复到之前的选择
            index = self.modelComboBox.findText(model_name)
            if index >= 0:
                self.modelComboBox.setCurrentIndex(index)

    def change_img(self):
        """上传并显示图片"""
        openfile_name = QFileDialog.getOpenFileName(self, '选择图片', '',
                                                    'Image files(*.jpg *.png *.jpeg)')
        img_name = openfile_name[0]
        if img_name == '':
            return

        try:
            # 保存并处理图片
            target_image_name = "images/tmp_up." + img_name.split(".")[-1]
            shutil.copy(img_name, target_image_name)

            # 读取并调整图片大小
            img_init = cv2.imread(target_image_name)
            h, w, c = img_init.shape
            scale = 300 / h
            img_show = cv2.resize(img_init, (0, 0), fx=scale, fy=scale)
            cv2.imwrite("images/show.png", img_show)

            # 调整图片大小为模型输入尺寸
            img_init = cv2.resize(img_init, (224, 224))
            cv2.imwrite('images/target.png', img_init)

            # 显示图片
            self.label_5.setScaledContents(True)
            self.label_5.setPixmap(QPixmap("images/show.png"))
            self.label_3.setText('')
            self.label_4.setText('')

        except Exception as e:
            print(f"❌ 图片处理出错: {str(e)}")
            QMessageBox.critical(self, "错误", f"图片处理失败: {str(e)}")

    def predict_img(self):
        """使用当前选择的模型进行预测"""
        if self.current_model is None:
            QMessageBox.warning(self, "警告", "当前模型未正确加载")
            return

        try:
            # 图像预处理
            data_transform = transforms.Compose([
                transforms.Resize(256),
                transforms.CenterCrop(224),
                transforms.ToTensor(),
                transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])
            ])

            # 加载和转换图像
            img = Image.open('images/target.png')
            img = data_transform(img)
            img = torch.unsqueeze(img, dim=0)

            # 执行预测
            with torch.no_grad():
                output = torch.squeeze(self.current_model(img.to(self.device))).cpu()
                predict = torch.softmax(output, dim=0)
                predict_cla = torch.argmax(predict).numpy()

            # 显示预测结果
            result_label = f"类别: {self.class_indict[str(predict_cla)]}"
            result_prob = f"置信度: {float(predict[predict_cla]):.4f}"

            self.label_3.setText(result_label)
            self.label_4.setText(result_prob)

        except Exception as e:
            print(f"❌ 预测过程出错: {str(e)}")
            QMessageBox.critical(self, "错误", f"预测失败: {str(e)}")

    def run_test(self, image_path, model_name="Vision Transformer"):
        """执行完整测试流程并返回结果"""
        if not os.path.exists(image_path):
            return {"status": "error", "message": f"测试图像不存在: {image_path}"}

        try:
            # 设置当前模型
            if self.models[model_name] is None:
                return {"status": "error", "message": f"模型 {model_name} 未正确加载"}
            self.current_model = self.models[model_name]

            # 处理图像
            target_image_name = "images/tmp_up." + image_path.split(".")[-1]
            shutil.copy(image_path, target_image_name)

            img_init = cv2.imread(target_image_name)
            img_init = cv2.resize(img_init, (224, 224))
            cv2.imwrite('images/target.png', img_init)

            # 预测
            data_transform = transforms.Compose([
                transforms.Resize(256),
                transforms.CenterCrop(224),
                transforms.ToTensor(),
                transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])
            ])

            img = Image.open('images/target.png')
            img = data_transform(img).unsqueeze(0)

            self.current_model.eval()
            with torch.no_grad():
                output = torch.squeeze(self.current_model(img.to(self.device))).cpu()
                predict = torch.softmax(output, dim=0)
                predict_cla = torch.argmax(predict).numpy()

            # 返回结果
            return {
                "status": "success",
                "predicted_class": self.class_indict[str(predict_cla)],
                "confidence": float(predict[predict_cla]),
                "all_probs": {self.class_indict[str(i)]: float(predict[i])
                              for i in range(len(predict))}
            }

        except Exception as e:
            return {"status": "error", "message": str(e)}


if __name__ == '__main__':
    app = QApplication(sys.argv)
    my_window = MyWindow()
    my_window.show()
    sys.exit(app.exec_())
